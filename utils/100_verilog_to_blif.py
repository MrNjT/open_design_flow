#!/usr/bin/env python
""" Provides the BlifGenerator class.

Generate a blif file from a given verilog netlist.
"""

__author__ = "Jinwook Jung"
__email__ = "jinwookjungs@gmail.com"
__date__ = "09/29/2015"

#from __future__ import print_function
from time import gmtime, strftime
import sys

def parse_cl():
    """ Parse command line and return dictionary. """

    import argparse
    parser = argparse.ArgumentParser(
                description='Convert a given gate-level verilog to a blif.')

    # Add arguments
    parser.add_argument(
            '-i', action="store", dest='src_v', required=True)
    parser.add_argument(
            '-o', action="store", dest='dest_blif', default='out.blif')

    opt = parser.parse_args()
    return opt.src_v, opt.dest_blif


class BlifGenerator(object):
    """ Blif netlist generator. """
    def __init__(self):
        self.__circuit = None
        self._inputs = list()
        self._outputs = list()
        self._gates = list()


    def read_verilog(self, src):
        """ Read the source verilog file. """
        lines = [x.rstrip() for x in open(src)]

        for line in lines:
            # if current line is blank or a comment:
            if line == '' or line.startswith('//'): 
                continue

            tokens = line.split()

            if tokens[0] == 'wire':
                continue

            elif tokens[0] == 'module':
                self._circuit = tokens[1]

            elif tokens[0] == 'input':
                self._inputs.append( [pin[:-1] for pin in tokens[1:]] )

            elif tokens[0] == 'output':
                self._outputs.append( [pin[:-1] for pin in tokens[1:]] )
        
            elif tokens.__len__() > 3:    # gate definitions
                gate_type = tokens[0] # string
                pins = tokens[3:-1] # list
                self._gates.append( [gate_type, pins] )


    def write_blif(self, dest):
        with open(dest, 'w') as f:
            f.write("# Generated by verilog_to_blif.py, %s\n"
                    % (strftime("%Y-%m-%d %H:%M:%S", gmtime())))
            f.write(".model %s\n\n" % (self._circuit))
            self._print_ports("inputs", self._inputs, f)
            self._print_ports("outputs", self._outputs, f)
            self._print_gates(self._gates, f)
            f.write(".end\n")


    def _print_ports(self, port_type, port_list, f):
        """ Print port definition. """
        # Flatten lists
        ports = [port for sublist in port_list for port in sublist]
        f.write(".%s " % (port_type))
        f.write(" ".join(ports))
        f.write("\n")


    def _print_gates(self, gate_list, f):
        def extract_pin_and_net(token):
            # token should be of .PIN(NET)
            # replace .,() with blank
            for c in ('.', ',', '(', ')'):
                token = token.replace(c, ' ')

            token = token.strip().split()
            pin, net = token[0], token[1]
            return pin, net

        f.write("\n# Gates\n")
        for gate in gate_list:
            if gate[0].upper().startswith('MS00'):
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    if pin_name.upper() == 'O': q_pin_net = net_name
                    if pin_name.upper() == 'D': d_pin_net = net_name
                
                f.write(".latch %s %s\n" % (d_pin_net, q_pin_net))

            elif gate[0].upper().startswith('VCC'):
                pin_name, net_name = extract_pin_and_net(gate[1][0])
                f.write(".gate one o=%s\n" % (net_name))

            else:
                f.write(".gate %s " % (gate[0]))
                # pins
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    f.write("%s=%s " % (pin_name, net_name))  
                f.write("\n")



if __name__ == '__main__':
    src, dest = parse_cl()

    print ("Input file:  " + src)
    print ("Output file: " + dest)
    sys.stdout.flush()

    blif_generator = BlifGenerator()
    blif_generator.read_verilog(src)
    blif_generator.write_blif(dest)

